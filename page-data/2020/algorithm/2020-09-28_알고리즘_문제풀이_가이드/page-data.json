{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020/algorithm/2020-09-28_알고리즘_문제풀이_가이드/","result":{"data":{"site":{"siteMetadata":{"title":"HaYoung's Log","author":"@Ha-Young","siteUrl":"https://ha-young.github.io","comment":{"utterances":"Ha-Young/my-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"94f5688b-78f3-57c9-909f-68000de92eef","excerpt":"문제 유형 파악하기 코딩 테스트를 볼 때 빠르게 문제 유형을 파악하는 방법을 공유합니다. :) 문제를 읽기전에 무조건 입출력 제한을 보자! 문제를 자세히 읽기전에 입출력 제한을 보는것이 중요합니다. 특히 입력 제한을 보면 어떤 시간복잡도 내에 풀어야 하는지 알 수 있습니다.\n예를들어 입력이 100 이하인 경우 높은 확률로 완전 탐색 문제입니다. 시간복잡도 O(n…","html":"<h2 id=\"문제-유형-파악하기\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%9C%A0%ED%98%95-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0\" aria-label=\"문제 유형 파악하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 유형 파악하기</h2>\n<p>코딩 테스트를 볼 때 빠르게 문제 유형을 파악하는 방법을 공유합니다. :)</p>\n<h2 id=\"문제를-읽기전에-무조건-입출력-제한을-보자\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%9D%BD%EA%B8%B0%EC%A0%84%EC%97%90-%EB%AC%B4%EC%A1%B0%EA%B1%B4-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%A0%9C%ED%95%9C%EC%9D%84-%EB%B3%B4%EC%9E%90\" aria-label=\"문제를 읽기전에 무조건 입출력 제한을 보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제를 읽기전에 무조건 입출력 제한을 보자!</h2>\n<p>문제를 자세히 읽기전에 입출력 제한을 보는것이 중요합니다. 특히 입력 제한을 보면 어떤 시간복잡도 내에 풀어야 하는지 알 수 있습니다.\n예를들어 입력이 100 이하인 경우 높은 확률로 완전 탐색 문제입니다. 시간복잡도 O(n3) 까지도 감당이 가능하기 때문에 플로이드 워셜과 같이 시간복잡도가 높은 알고리즘도 사용이 가능합니다. 보통 다음과 같이 판단하시면 됩니다.</p>\n<ul>\n<li>\n<p>입력이 100 이하인 경우</p>\n<ul>\n<li>완전 탐색</li>\n<li>백트래킹</li>\n</ul>\n</li>\n<li>\n<p>입력이 10,000 이하인 경우</p>\n<ul>\n<li>최대 O(n2) 이내로 끝내야하는 문제</li>\n<li>문제에 따라 O(n2 log n)까지는 허용</li>\n<li>n*n 2차원 리스트를 모두 순회해야하는 문제가 많음</li>\n</ul>\n</li>\n<li>\n<p>입력이 1,000,000 이하인 경우</p>\n<ul>\n<li>최대 O(n log n)으로 끝내야하는 문제</li>\n<li>힙, 우선순위 큐</li>\n<li>정렬</li>\n<li>동적 계획법</li>\n<li>위상 정렬</li>\n<li>다익스트라 알고리즘</li>\n</ul>\n</li>\n<li>\n<p>입력이 100,000,000 이하인 경우</p>\n<ul>\n<li>최대 O(n)으로 끝내야하는 문제</li>\n<li>동적 계획법</li>\n<li>그리디</li>\n</ul>\n</li>\n<li>\n<p>그 이상인 경우</p>\n<ul>\n<li>최대 O(log n)으로 끝내야하는 문제가 많음</li>\n<li>거의 안나오는 문제 유형</li>\n<li>이진탐색</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"문제-유형\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%9C%A0%ED%98%95\" aria-label=\"문제 유형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 유형</h2>\n<p>100%는 아니지만 높은 확률이라고 봐주시면 좋습니다. :)\n코딩 테스트에서 많이 나오는 유형을 추렸습니다.</p>\n<h3 id=\"입력값이-작은-문제\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EB%A0%A5%EA%B0%92%EC%9D%B4-%EC%9E%91%EC%9D%80-%EB%AC%B8%EC%A0%9C\" aria-label=\"입력값이 작은 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입력값이 작은 문제</h3>\n<p>위에서 적었듯 높은 확률로 완전 탐색 혹은 백트래킹 문제입니다.\n구현력이 중요한 문제로 출제될 가능성이 높습니다.</p>\n<h3 id=\"지도가-주어지고-채워진-영역을-찾아야하는-경우\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EB%8F%84%EA%B0%80-%EC%A3%BC%EC%96%B4%EC%A7%80%EA%B3%A0-%EC%B1%84%EC%9B%8C%EC%A7%84-%EC%98%81%EC%97%AD%EC%9D%84-%EC%B0%BE%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"지도가 주어지고 채워진 영역을 찾아야하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지도가 주어지고 채워진 영역을 찾아야하는 경우</h3>\n<p>높은 확률로 BFS, DFS 문제입니다. FloodFill과 같이 정직한 방식으로 나오거나 전염병 문제나 치즈 문제(<a href=\"https://www.acmicpc.net/problem/2636\">https://www.acmicpc.net/problem/2636</a>)처럼 살짝 변형되서 나오는 경우가 있습니다.</p>\n<h3 id=\"그래프-그림이-있는-경우\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%ED%94%84-%EA%B7%B8%EB%A6%BC%EC%9D%B4-%EC%9E%88%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"그래프 그림이 있는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래프 그림이 있는 경우</h3>\n<p>이 경우 높은 확률로 세 가지 유형 중 하나입니다.</p>\n<ul>\n<li>최단 거리 찾기</li>\n<li>최소 신장 트리</li>\n<li>위상 정렬 문제에서 가장 빠른 길, 최단 거리와 비슷한 키워드가 나온다면 당연히 최단 거리 찾기 유형이고 X 비용 내로 갈 수 있는 길을 찾아라와 같은 키워드가 나와도 최단 거리 찾기 유형입니다. 다익스트라, BFS, DFS 등이 사용될 수 있습니다.</li>\n</ul>\n<p>최소 신장 트리 문제는 보통 가장 저렴한 방법으로 모든 경로 연결해라 등의 키워드로 출제됩니다. 경로가 아니라 통신망, 전송 시간, 회로, 배관 등 다양한 용어로 나올 수는 있지만 핵심은 모든 경로를 가장 싸게 연결해라입니다. 그래프는 양방향일수도 단방향일수도 있습니다. 크루스칼, 프림 알고리즘을 사용할 수 있습니다.</p>\n<p>위상 정렬은 순서를 정해야할 때 사용됩니다. 보통 순서, 차례 등의 키워드가 나오면 위상 정렬 문제입니다.</p>\n<h3 id=\"x라는-조건을-만족하는-가장-최대최소값을-찾아라\" style=\"position:relative;\"><a href=\"#x%EB%9D%BC%EB%8A%94-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%A7%8C%EC%A1%B1%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%EC%B5%9C%EB%8C%80%EC%B5%9C%EC%86%8C%EA%B0%92%EC%9D%84-%EC%B0%BE%EC%95%84%EB%9D%BC\" aria-label=\"x라는 조건을 만족하는 가장 최대최소값을 찾아라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>X라는 조건을 만족하는 가장 최대/최소값을 찾아라</h3>\n<p>이 경우 높은 확률로 결정 문제입니다. 파라메트릭 서치를 이용해서 풀 수 있습니다.</p>\n<h3 id=\"실시간으로-정렬이-이루어져야-하는-경우\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A0%AC%EC%9D%B4-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A0%B8%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"실시간으로 정렬이 이루어져야 하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실시간으로 정렬이 이루어져야 하는 경우</h3>\n<p>이 문제 유형은 많이 봤었죠? 높은 확률로 우선순위 큐 혹은 힙을 사용하는 문제입니다.</p>\n<h3 id=\"dp-문제\" style=\"position:relative;\"><a href=\"#dp-%EB%AC%B8%EC%A0%9C\" aria-label=\"dp 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DP 문제</h3>\n<p>보통 완전 탐색처럼 시간이 오래걸리면 안되는데 특별한 알고리즘을 사용하는 문제가 아닐거 같을 때는 높은 확률로 DP 문제입니다. 다른 문제처럼 딱봐도 이거네! 하는 특징이 없어서 보통 문제를 보고 바로 유형을 판단하기 힘든 경우 DP처럼 풀 수 있는지 생각해봐야 합니다. 종이를 꺼내고 다음과 같은 방식으로 해보셔도 괜찮을 것 같습니다.</p>\n<ol>\n<li>문제를 따라 먼저 초기값을 적는다.</li>\n<li>초기값을 포함해 모든 상태값을 적는다.</li>\n<li>현재상태를 통해 다음 값을 구할 수 있는지 판단한다.</li>\n<li>혹은 이전 상태들을 통해 현재 값을 구할 수 있는지 판단한다. 이런식으로 여러 번 해보고 식을 만들 수 있다면 100% DP 문제입니다.</li>\n</ol>\n<h3 id=\"문자열이-주어지는-경우\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%B4-%EC%A3%BC%EC%96%B4%EC%A7%80%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"문자열이 주어지는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열이 주어지는 경우</h3>\n<p>구현력 문제인 경우가 많습니다. 문자열을 자르거나, 붙이거나 탐색하는 문제가 대부분입니다. 문자열을 탐색하는 알고리즘이 필요한 경우 KMP 알고리즘을 사용할 수 있지만 보통 파이썬과 같은 스크립트 언어에선 문자열 탐색이 빌트인으로 존재하기 때문에 구현에만 집중하면 됩니다.</p>\n<h3 id=\"현재-상황에서-가장-최적인-선택을-해야하는-경우\" style=\"position:relative;\"><a href=\"#%ED%98%84%EC%9E%AC-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-%EA%B0%80%EC%9E%A5-%EC%B5%9C%EC%A0%81%EC%9D%B8-%EC%84%A0%ED%83%9D%EC%9D%84-%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"현재 상황에서 가장 최적인 선택을 해야하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>현재 상황에서 가장 최적인 선택을 해야하는 경우</h3>\n<p>문제에서 항상 최적의 선택을 해야하는 경우 혹은 가장 많은 선택을 할 수 있는, 가장 작은/큰 등의 키워드가 들어가면 그리디 문제일 가능성이 높습니다. 위에서 잠깐 말했던 최소 신장 트리도 그리디의 일종입니다.</p>","frontmatter":{"title":"알고리즘 문제풀이 가이드!","date":"September 28, 2020"}}},"pageContext":{"slug":"/2020/algorithm/2020-09-28_알고리즘_문제풀이_가이드/","previous":{"fields":{"slug":"/2020/data-structrue/2020-09-22-자료구조-Tree에-대해-알아보자---2-이진탐색트리-구현/"},"frontmatter":{"title":"자료구조 Tree에 대해 알아보자 - 2 이진 탐색 트리 구현","category":"algorithm","draft":false}},"next":{"fields":{"slug":"/2020/algorithm/2020-09-28_코드리뷰_파이썬_꿀팁/"},"frontmatter":{"title":"코드리뷰를 통해 배운 파이썬, 파이썬을 활용한 코딩문제 꿀팁!","category":"algorithm-tip","draft":false}}}}}