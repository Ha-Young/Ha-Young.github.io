{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020/cpp/2020-08-05-C++-String-문자열/","result":{"data":{"site":{"siteMetadata":{"title":"HaYoung's Log","author":"@Ha-Young","siteUrl":"https://ha-young.github.io","comment":{"utterances":"Ha-Young/my-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"0badc31f-38c9-5259-8d20-f2063ba3ab89","excerpt":"String 문자열 우리가 c언어나 c++언어에서 문자열을 처리할 때 문제가 되었던 것이 있는데, 이와 같은 상황에서 애러가 발생하는 케이스가 있다. 아무것도 읽지 못했을 때 한줄에 문자가 256자 이상일 때 (즉, 버퍼크기가 충분하지 않을 때) 여기서 대안으로 나온것이 std::string 클래스 이다 그리고 이 string 클래스는 이후 등장하는 언어에 기본적인 원시 타입이 된다. 우리가 알고있는 그 string 타입이 첫시작은 C++ 클래스. 과 같이 사용가능. string…","html":"<h3 id=\"string-문자열\" style=\"position:relative;\"><a href=\"#string-%EB%AC%B8%EC%9E%90%EC%97%B4\" aria-label=\"string 문자열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String 문자열</h3>\n<p>우리가 c언어나 c++언어에서 문자열을 처리할 때 문제가 되었던 것이 있는데,</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">char line[LINE_LENGTH];\ncin.getline(line, LINE_LENGTH);</code></pre></div>\n<p>이와 같은 상황에서 애러가 발생하는 케이스가 있다.</p>\n<ol>\n<li>아무것도 읽지 못했을 때</li>\n<li>한줄에 문자가 256자 이상일 때 (즉, 버퍼크기가 충분하지 않을 때)</li>\n</ol>\n<p>여기서 대안으로 나온것이</p>\n<p><strong>std::string 클래스</strong> 이다</p>\n<p>그리고 이 string 클래스는 이후 등장하는 언어에 기본적인 원시 타입이 된다.</p>\n<p>우리가 알고있는 그 string 타입이 첫시작은 C++ 클래스.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main()\n{\n    string str1 = &quot;Hellow&quot;;\n    string str2 = &quot;World&quot;;\n\n    cout &lt;&lt; str1 &lt;&lt; str2 &lt;&lt; endl;\n}</code></pre></div>\n<p>과 같이 사용가능.</p>\n<h3 id=\"string-클래스\" style=\"position:relative;\"><a href=\"#string-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"string 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>string 클래스</h3>\n<p>string 클래스를 이용한 문자열은 앞서 나온 char[] (char array)와 달리 길이가 증가할 수 있다.\n이를 이용해 대입(Assignment)과 덧붙이기(Appending)이 가능하다.</p>\n<ul>\n<li>c언어</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> firstName<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Ha-Young\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> fullName<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>fullName<span class=\"token punctuation\">,</span> firstName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 대입. 불완전</span>\n<span class=\"token function\">strcat</span><span class=\"token punctuation\">(</span>fullName<span class=\"token punctuation\">,</span> <span class=\"token string\">\" CHOI\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 덧붙이기. 불완전</span></code></pre></div>\n<p>c언어를 보면 다음과 같이 문자열을 처리 할 수 있는데,\n고정된 크기이기 때문에 너무나도 불완전하다. (공간이 남거나 넘어버리거나)</p>\n<ul>\n<li>c++언어</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">string firstName=&quot;Ha-Young&quot;;\nstring fullName;\n\nfullName = firstName;\nfullName += &quot; CHOI&quot;;</code></pre></div>\n<p>c++언어의 string을 이용하면 위 char array로 표현하던 문자열과 달리 문자열 처리가 훨씬 간편해 진다.</p>\n<ul>\n<li>c언어</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">snprintf</span><span class=\"token punctuation\">(</span>fullName<span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"%s %s\"</span><span class=\"token punctuation\">,</span> firstName<span class=\"token punctuation\">,</span> lastName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>c++ string</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">fullName = firstName + &quot; &quot; + lastName;</code></pre></div>\n<p>여기에 더해 string 클래스는 비교연산도 가능하다.</p>\n<p>==, !=, >, &#x3C;, &#x3C;=, >= 와 같은.</p>\n<h3 id=\"string-클래스-메서드\" style=\"position:relative;\"><a href=\"#string-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"string 클래스 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String 클래스 메서드</h3>\n<p>C++의 String은 Class이기 때문에 메서드도 있다.</p>\n<ul>\n<li>size(), length() - 문자열 길이 반환</li>\n<li>\n<p>c_str() - 해당 string이 가지고 있는 문자배열의 시작주소를 가리키는 포인터를 반환</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">string line;\ncin &gt;&gt; line;\nconst char* cLine = line.c_str();</code></pre></div>\n</li>\n<li>그 외 함수는 <a href=\"%22http://www.cplusplus.com/reference/string/string/%22\">여기</a>를 참조.</li>\n</ul>\n<h3 id=\"string-속에-문자-접근\" style=\"position:relative;\"><a href=\"#string-%EC%86%8D%EC%97%90-%EB%AC%B8%EC%9E%90-%EC%A0%91%EA%B7%BC\" aria-label=\"string 속에 문자 접근 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>string 속에 문자 접근?</h3>\n<p>string 속에 문자접근이 가능할까?</p>\n<p>c와 같다. (배열 index로 접근) -> 말고도 at()도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">firstName[2] = &#39;-&#39;;</code></pre></div>\n<p>함수(연산자오버로딩) 반환값인데 대입이 가능한 이유는 뭘까?</p>\n<p>그것은 [] 연산자 오버로딩함수가 참조형으로 반환했기 때문에 가능하다.</p>\n<h3 id=\"한-줄-읽기\" style=\"position:relative;\"><a href=\"#%ED%95%9C-%EC%A4%84-%EC%9D%BD%EA%B8%B0\" aria-label=\"한 줄 읽기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한 줄 읽기</h3>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">string mailheader;\ngetline(cin, mailheader, &#39;@&#39;); // @문자까지 읽기</code></pre></div>\n<h3 id=\"string과-stream\" style=\"position:relative;\"><a href=\"#string%EA%B3%BC-stream\" aria-label=\"string과 stream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>string과 stream</h3>\n<p>string과 stream을 이용하여 아래와 같은 조건을 만족할 때까지 스트림에서 문자들을 꺼내 string에 저장 할 수 있다.</p>\n<ul>\n<li>end-of-file 만날 때 (eofbit 값이 true가 됨)</li>\n<li>구분문자(delimiter)를 만날 때 까지 (구분문자는 버려짐)</li>\n</ul>\n<p><strong><SStream></strong></p>\n<ul>\n<li>\n<p>std:istringstream</p>\n<ul>\n<li>cin과 비슷. 키보드 대신 string으로 읽어온다.</li>\n<li>sscanf()와 비슷</li>\n</ul>\n</li>\n<li>\n<p>std:ostringstream</p>\n<ul>\n<li>cout과 비슷. 콘솔 대신 string에 출력.</li>\n<li>sprintf()와 비슷</li>\n</ul>\n</li>\n<li>자주 쓰이지 않는다.</li>\n</ul>\n<h3 id=\"근데-c의-헤더를-가져다-써도-되나요\" style=\"position:relative;\"><a href=\"#%EA%B7%BC%EB%8D%B0-c%EC%9D%98-%ED%97%A4%EB%8D%94%EB%A5%BC-%EA%B0%80%EC%A0%B8%EB%8B%A4-%EC%8D%A8%EB%8F%84-%EB%90%98%EB%82%98%EC%9A%94\" aria-label=\"근데 c의 헤더를 가져다 써도 되나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>근데, C의 헤더를 가져다 써도 되나요?</h3>\n<p>C++에서는 C의 함수들이 많이사용되고 있는데,</p>\n<p>그이유는 성능상의 이유. C언어의 함수들이 더 빠르게 동작한다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">C</th>\n<th align=\"center\">C++</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">&lt;string.h&gt;</code></td>\n<td align=\"center\"><code class=\"language-text\">&lt;cstring&gt;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">&lt;stdio.h&gt;</code></td>\n<td align=\"center\"><code class=\"language-text\">&lt;cstdio&gt;</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">&lt;ctype.h&gt;</code></td>\n<td align=\"center\"><code class=\"language-text\">&lt;cctype&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<p>등등</p>\n<h3 id=\"그럼-string-클래스는-어떻게-동작\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-string-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91\" aria-label=\"그럼 string 클래스는 어떻게 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼 String 클래스는 어떻게 동작?</h3>\n<p>그래서 결국 String 클래스는 문자배열길이에 관해 고민 할 필요가 없다.</p>\n<p>근데 어떻게 동작하는가?</p>\n<p>string 클래스는 내부적으로 char* array가 존재하고</p>\n<p>포인터 변수, 크기변수 등을 제외하고 char array는 heap영역에 저장한다. (memory allocation)</p>\n<p>플랫폼마다 다르지만, 보통 처음 16바이트로 설정하고 그 후에 크기가 모자라면 재할당(기존 힙영역 free)</p>\n<p>32바이트, 64바이트 … 와 같은 식으로 늘려간다.</p>\n<h3 id=\"string-단점은\" style=\"position:relative;\"><a href=\"#string-%EB%8B%A8%EC%A0%90%EC%9D%80\" aria-label=\"string 단점은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String 단점은?</h3>\n<p>하지만, String이라고 만능은 아닌것이</p>\n<ul>\n<li>힙(Heap) 메모리 할당은 느리다.</li>\n<li>메모리 단편화(memory fragmentation)문제</li>\n<li>내부 버퍼의 증가는 멀티 쓰레드 환경에서 안전하지 않을 수 있다.</li>\n<li>\n<p>여전히 C++을 쓰는 업계가 어디인지 생각해보자.</p>\n<ul>\n<li>그래서 여전히 sprintf와 char[]을 매우 많이 사용한다. (성능상의 이유)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"stack-메모리---heap-메모리\" style=\"position:relative;\"><a href=\"#stack-%EB%A9%94%EB%AA%A8%EB%A6%AC---heap-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"stack 메모리   heap 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack 메모리 &#x3C;-> Heap 메모리</h3>\n<ul>\n<li>Stack 메모리 : exe가 컴파일 될 때 가지는 메모리. 빠르다.</li>\n<li>Heap 메모리 : os가 가지고 있는 모든 메모리. 느리다. 메모리 단편화 문제 야기(조각조각 나서 연속된 메모리 X - 잦은 길이변화가 있다면)</li>\n</ul>\n<h3 id=\"막간상식---pointer의-위치마다-달라지는-변화\" style=\"position:relative;\"><a href=\"#%EB%A7%89%EA%B0%84%EC%83%81%EC%8B%9D---pointer%EC%9D%98-%EC%9C%84%EC%B9%98%EB%A7%88%EB%8B%A4-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94-%EB%B3%80%ED%99%94\" aria-label=\"막간상식   pointer의 위치마다 달라지는 변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>막간상식 - pointer의 위치마다 달라지는 변화</h3>\n<ul>\n<li>const char* -> pointer to const char -> const char를 가리키는 포인터</li>\n<li>char* const -> const pointer to char -> const pointer가 가르키는 char</li>\n<li>const char* const -> const pointer to const char</li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#string-%EB%AC%B8%EC%9E%90%EC%97%B4\">String 문자열</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#string-%ED%81%B4%EB%9E%98%EC%8A%A4\">string 클래스</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#string-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C\">String 클래스 메서드</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#string-%EC%86%8D%EC%97%90-%EB%AC%B8%EC%9E%90-%EC%A0%91%EA%B7%BC\">string 속에 문자 접근?</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#%ED%95%9C-%EC%A4%84-%EC%9D%BD%EA%B8%B0\">한 줄 읽기</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#string%EA%B3%BC-stream\">string과 stream</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#%EA%B7%BC%EB%8D%B0-c%EC%9D%98-%ED%97%A4%EB%8D%94%EB%A5%BC-%EA%B0%80%EC%A0%B8%EB%8B%A4-%EC%8D%A8%EB%8F%84-%EB%90%98%EB%82%98%EC%9A%94\">근데, C의 헤더를 가져다 써도 되나요?</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#%EA%B7%B8%EB%9F%BC-string-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91\">그럼 String 클래스는 어떻게 동작?</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#string-%EB%8B%A8%EC%A0%90%EC%9D%80\">String 단점은?</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#stack-%EB%A9%94%EB%AA%A8%EB%A6%AC---heap-%EB%A9%94%EB%AA%A8%EB%A6%AC\">Stack 메모리 &#x3C;-> Heap 메모리</a></li>\n<li><a href=\"/2020/cpp/2020-08-05-C++-String-%EB%AC%B8%EC%9E%90%EC%97%B4/#%EB%A7%89%EA%B0%84%EC%83%81%EC%8B%9D---pointer%EC%9D%98-%EC%9C%84%EC%B9%98%EB%A7%88%EB%8B%A4-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94-%EB%B3%80%ED%99%94\">막간상식 - pointer의 위치마다 달라지는 변화</a></li>\n</ul>","frontmatter":{"title":"C++ String 문자열","date":"August 05, 2020"}}},"pageContext":{"slug":"/2020/cpp/2020-08-05-C++-String-문자열/","previous":{"fields":{"slug":"/2020/cpp/2020-08-05-C++-Reference-(참조)/"},"frontmatter":{"title":"C++ Reference (참조)","category":"c++","draft":false}},"next":{"fields":{"slug":"/2020/cpp/2020-08-11-C++-파일-입출력-(IO)/"},"frontmatter":{"title":"C++ 파일 입출력 (I/O)","category":"c++","draft":false}}}}}