{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/","result":{"data":{"site":{"siteMetadata":{"title":"HaYoung's Log","author":"@Ha-Young","siteUrl":"https://ha-young.github.io","comment":{"utterances":"Ha-Young/my-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"ee4a9d2e-fb7c-59d8-b67d-9c30c2a2933f","excerpt":"문제 설명 Given the  of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: img Example 2: img Constraints: The number of nodes in the tree is in the range .  Follow up: Could you solve it both recursively and iteratively…","html":"<h2 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h2>\n<p>Given the <code class=\"language-text\">root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>\n<p><strong>Example 1:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg\" alt=\"img\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: root = [1,2,2,3,4,4,3]\nOutput: true</code></pre></div>\n<p><strong>Example 2:</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg\" alt=\"img\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: root = [1,2,2,null,3,null,3]\nOutput: false</code></pre></div>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li>The number of nodes in the tree is in the range <code class=\"language-text\">[1, 1000]</code>.</li>\n<li><code class=\"language-text\">-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p>\n<h2 id=\"나의-풀이\" style=\"position:relative;\"><a href=\"#%EB%82%98%EC%9D%98-%ED%92%80%EC%9D%B4\" aria-label=\"나의 풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>나의 풀이</h2>\n<h3 id=\"소스\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%8A%A4\" aria-label=\"소스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소스</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class=\"token comment\">/**\n * @param {TreeNode} root\n * @return {boolean}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">isSymmetric</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> leftSubTree <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> rightSubTree <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">checkIsMirrorTree</span><span class=\"token punctuation\">(</span>leftSubTree<span class=\"token punctuation\">,</span> rightSubTree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">checkIsMirrorTree</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">leftSubTree<span class=\"token punctuation\">,</span> rightSubTree</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>leftSubTree <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>rightSubTree<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftSubTree <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>rightSubTree<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rightSubTree <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>leftSubTree<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftSubTree<span class=\"token punctuation\">.</span>val <span class=\"token operator\">!==</span> rightSubTree<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">checkIsMirrorTree</span><span class=\"token punctuation\">(</span>leftSubTree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> rightSubTree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">checkIsMirrorTree</span><span class=\"token punctuation\">(</span>leftSubTree<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> rightSubTree<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"설명\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EB%AA%85\" aria-label=\"설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설명</h3>\n<p>한번에 다 못풀었다.</p>\n<p>맨 처음 풀이 시도는 root 노드 기준으로 left tree와 , right tree로 나누고,</p>\n<p>각 tree의 depth에 해당하는 노드들을 가지고 있다가 right노드를 reverse시킨 후 비교해나가는 방식으로,</p>\n<p>비교가 완료되면 다음 depth에 해당하는 노드들을 새로 담아야 되었었는데, 너무 번거로워서 아닐거라 생각하고 다른사람의 풀이를 먼저 참고했다.</p>\n<p>힌트를 얻어서 완성한 코드가 위와 같은데,</p>\n<p>leftSubTree와 rightSubTree 를 각각 받아서 루트부터 재귀적으로 비교해나가는 방식이다.</p>\n<p>checkMirror 핵심 아이디어는 </p>\n<ol>\n<li>루트의 값을 먼저 비교하고, </li>\n<li>루트의 왼쪽 트리의 왼쪽과 오른쪽 트리의 오른쪽이 같은지 확인</li>\n<li>루트의 왼쪽트리의 오른쪽과 오른쪽트리의 왼쪽이 같은지 확인</li>\n</ol>\n<p>이다.</p>\n<p>Mirroring되어있는 트리는 그 subTree들이 왼쪽, 오른쪽이 바뀌어져있는걸 알아차리는 것이 핵심.</p>\n<h2 id=\"다른사람의-풀이\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%A5%B8%EC%82%AC%EB%9E%8C%EC%9D%98-%ED%92%80%EC%9D%B4\" aria-label=\"다른사람의 풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다른사람의 풀이</h2>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">isSymmetric</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token function\">isMirror</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">isMirror</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">leftSub<span class=\"token punctuation\">,</span> rightSub</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftSub <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> rightSub <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftSub <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> rightSub <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>leftSub<span class=\"token punctuation\">.</span>val <span class=\"token operator\">==</span> rightSub<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isMirror</span><span class=\"token punctuation\">(</span>leftSub<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span> rightSub<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isMirror</span><span class=\"token punctuation\">(</span>leftSub<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span> rightSub<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>방식은 나와 같지만, 코드가 매우 간결하다.</p>","tableOfContents":"<ul>\n<li><a href=\"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\">문제 설명</a></li>\n<li>\n<p><a href=\"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/#%EB%82%98%EC%9D%98-%ED%92%80%EC%9D%B4\">나의 풀이</a></p>\n<ul>\n<li><a href=\"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/#%EC%86%8C%EC%8A%A4\">소스</a></li>\n<li><a href=\"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/#%EC%84%A4%EB%AA%85\">설명</a></li>\n</ul>\n</li>\n<li><a href=\"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/#%EB%8B%A4%EB%A5%B8%EC%82%AC%EB%9E%8C%EC%9D%98-%ED%92%80%EC%9D%B4\">다른사람의 풀이</a></li>\n</ul>","frontmatter":{"title":"[Javascript] LeetCode - 101: Symmetric Tree Lv-Easy (DFS&BFS)","date":"March 14, 2021"}}},"pageContext":{"slug":"/2021/algorithm_javascript/LeetCode-101_Symmetric_Tree_Lv-Easy_DFS-BFS/","previous":{"fields":{"slug":"/2021/algorithm_javascript/Leet_Code-559_Maximum_Depth_of_ N-ary_Tree-Easy-BFS-DFS/"},"frontmatter":{"title":"[Javascript] LeetCode - 559: Maximum Depth of N-ary Tree Lv-Easy (DFS&BFS)","category":"algorithm","draft":false}},"next":{"fields":{"slug":"/2021/algorithm_javascript/LeetCode-529_Minesweeper_Lv-Medium_DFS-BFS/"},"frontmatter":{"title":"[Javascript] LeetCode - 529: Minesweeper Lv-Medium (DFS&BFS)","category":"algorithm","draft":false}}}},"staticQueryHashes":["1402886152","145675779","3128451518"]}